# 에이전트 팀 실습 가이드

> 단계별로 난이도를 높여가며, 실제 프로젝트에서 바로 사용할 수 있는 시나리오 모음

---

## 사전 준비

### 1. 에이전트 팀 활성화

`settings.json`에 추가하거나 환경 변수로 설정:

```json
{
  "env": {
    "CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS": "1"
  }
}
```

또는 셸에서:

```bash
export CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1
```

### 2. 표시 모드 확인

| 모드 | 설정 | 권장 상황 |
|---|---|---|
| In-process | `"teammateMode": "in-process"` | tmux 없는 환경, 처음 시작할 때 |
| 분할 창 | `"teammateMode": "tmux"` | tmux/iTerm2 있는 환경, 팀원 출력을 동시에 보고 싶을 때 |

> Windows에서는 **in-process**를 사용하라. 분할 창은 VS Code 통합 터미널/Windows Terminal에서 미지원.

### 3. 키보드 단축키 (In-process 모드)

| 단축키 | 동작 |
|---|---|
| `Shift+Up/Down` | 팀원 선택 |
| `Enter` (팀원 선택 후) | 팀원 세션 보기 |
| `Escape` | 현재 턴 중단 |
| `Ctrl+T` | 작업 목록 토글 |
| `Shift+Tab` | 위임 모드 전환 |

---

## 시나리오 1: 첫 번째 팀 만들기 (입문)

### 목표

에이전트 팀의 기본 흐름을 체험한다: 팀 생성 → 팀원 작업 → 결과 종합 → 팀 정리.

### 프롬프트

```
에이전트 팀을 만들어서 새 CLI 도구 프로젝트에 TypeScript를 쓸지
JavaScript를 쓸지 장단점을 분석해줘. 팀원 2명으로 구성해.

- 팀원 1: TypeScript 옹호자. TypeScript를 써야 하는 가장 강력한
  논거를 조사하고 발표해.
- 팀원 2: JavaScript 옹호자. 순수 JavaScript를 유지해야 하는
  가장 강력한 논거를 조사하고 발표해.

둘 다 끝나면 양쪽 주장을 종합해서 균형 잡힌 추천안을 만들어줘.
```

### 관찰 포인트

- [ ] 팀이 생성되고 작업 목록이 만들어지는 과정 확인
- [ ] `Shift+Up/Down`으로 각 팀원의 진행 상황 확인
- [ ] 두 팀원이 동시에 작업하는 것을 관찰
- [ ] 리더가 두 결과를 종합하는 과정 확인
- [ ] 팀 정리: `팀 정리해줘`

### 예상 결과

리더가 TypeScript 찬성/반대 논거를 종합한 요약 보고서를 생성한다.

### 변형 연습

> 팀원 수를 3명으로 늘려보기: Deno 옹호자 추가

```
세 번째 팀원을 추가해. Node.js 대신 Deno를 써야 한다고 주장하는 역할이야.
```

---

## 시나리오 2: 병렬 코드 검토 (기본)

### 목표

실제 코드베이스에서 관점별로 분리된 병렬 코드 검토를 수행한다.

### 사전 조건

- 검토할 코드가 있는 프로젝트 디렉토리에서 실행
- 또는 PR이 있는 Git 저장소에서 실행

### 프롬프트 (PR 기반)

```
이 브랜치의 최근 커밋 3개를 검토할 에이전트 팀을 만들어줘.
검토자 3명을 생성해:

- 보안 검토자: 인젝션 취약점, 인증 문제, 시크릿 노출,
  입력 검증 누락에 집중
- 성능 검토자: N+1 쿼리, 불필요한 메모리 할당, 캐싱 기회 누락,
  알고리즘 복잡도에 집중
- 유지보수성 검토자: 코드 가독성, 네이밍 컨벤션, 테스트 커버리지 누락,
  문서 정확도에 집중

각 검토자는:
1. git log와 git diff를 실행해서 변경 사항 파악
2. 변경된 모든 파일 검토
3. 심각도별로 발견 사항 보고 (Critical / Warning / Suggestion)
4. 구체적인 파일:라인 참조 포함

모든 검토가 끝나면 심각도별로 정리한 통합 검토 요약을 만들어.
중복된 발견 사항은 제거해줘.
```

### 프롬프트 (디렉토리 기반, PR 없이)

```
src/ 디렉토리의 코드를 검토할 에이전트 팀을 만들어줘.
검토자 3명을 생성해:

- 보안 검토자: 취약점 찾기 (OWASP Top 10, 시크릿, 인증)
- 품질 검토자: 코드 스멜, 중복 코드, 네이밍 이슈 찾기
- 테스트 검토자: 테스트 커버리지 분석, 테스트되지 않은 엣지 케이스 찾기

각 검토자는 심각도 등급과 함께 발견 사항을 보고해.
우선순위가 매겨진 액션 리스트로 종합해줘.
```

### 관찰 포인트

- [ ] 세 검토자가 동일 파일을 다른 관점으로 분석하는 차이 확인
- [ ] 중복 발견 사항이 있는지 확인 (리더가 어떻게 통합하는지)
- [ ] 각 검토자의 전문성 차이 관찰

### 팁

> 검토가 너무 광범위하면 범위를 좁혀라:

```
마지막 커밋에서 변경된 파일만 집중해.
각 검토자는 최대 10개 발견 사항만 보고해.
```

---

## 시나리오 3: 경쟁 가설 디버깅 (중급)

### 목표

버그의 원인이 불명확할 때, 여러 팀원이 각자 다른 가설을 병렬로 조사하고 서로 반박한다.

### 사전 조건

- 실제 버그가 있는 프로젝트 또는 재현 가능한 이슈

### 프롬프트 (실제 버그)

```
버그: [여기에 실제 버그 설명 작성]

이 버그를 조사할 에이전트 팀을 팀원 4명으로 만들어줘.
각 팀원은 서로 다른 가설을 추적해야 해:

- 팀원 1 (상태 가설): 잘못된 상태 관리나 레이스 컨디션이 원인이다
- 팀원 2 (데이터 가설): 잘못된 입력 데이터나 데이터 변환 오류가 원인이다
- 팀원 3 (설정 가설): 환경 설정, 의존성 버전, 빌드 설정이 원인이다
- 팀원 4 (로직 가설): 핵심 알고리즘의 논리적 오류가 원인이다

규칙:
1. 각 팀원은 자기 가설을 뒷받침하는 증거를 찾아야 한다
2. 각 팀원은 자기 가설을 반증하려는 시도도 해야 한다
3. 팀원들은 서로 메시지를 보내서 상대방의 발견에 도전해야 한다
4. 증거가 명확히 가설을 제거하면, 해당 팀원은 인정하고
   남은 가설 조사를 도와야 한다

최종 근본 원인 분석을 뒷받침 증거와 함께 종합해줘.
```

### 프롬프트 (연습용, 의도적 버그)

먼저 의도적 버그가 있는 파일을 만든다:

```
practice-bug.js에 간단한 Express.js 서버를 만들어줘.
의도적으로 미묘한 버그를 넣어: JWT 토큰을 검증하는 미들웨어인데,
토큰이 "Bearer "로 시작할 때 대소문자를 구분하는 비교를 해서
"bearer "나 "BEARER "로 시작하면 검증을 건너뛰는 버그야.
팀에게는 버그 유형을 알려주지 마.
```

그 다음 팀을 생성한다:

```
방금 만든 practice-bug.js에 버그가 있어.
에이전트 팀을 팀원 3명으로 만들어서 이 버그를 찾아줘.
각 팀원은 서로 다른 가설을 조사하고 서로 토론해야 해.
```

### 관찰 포인트

- [ ] 팀원 간 직접 메시지로 가설을 반박하는 과정 확인
- [ ] 가설이 제거되는 과정 (어떤 근거로?)
- [ ] 최종 합의에 도달하는 과정
- [ ] `Shift+Up/Down`으로 각 팀원의 조사 과정 실시간 관찰

---

## 시나리오 4: 교차 계층 기능 개발 (중급)

### 목표

프론트엔드, 백엔드, 테스트를 각각 다른 팀원이 담당하여 하나의 기능을 병렬로 개발한다.

### 사전 조건

- 풀스택 프로젝트 (또는 연습용 프로젝트 생성)

### 프롬프트

```
"사용자 프로필 설정" 기능을 추가해야 해.
에이전트 팀을 팀원 3명으로 만들어줘. 각 팀원은 Sonnet 모델을 사용해.

- 백엔드 개발자: API 엔드포인트 구현
  - GET /api/users/:id/settings
  - PUT /api/users/:id/settings
  - 담당 파일: src/api/settings.ts, src/models/settings.ts
  - 입력 검증과 에러 핸들링 포함 필수

- 프론트엔드 개발자: 설정 UI 구현
  - 이름, 이메일, 알림 설정이 있는 설정 폼
  - 담당 파일: src/components/Settings.tsx, src/hooks/useSettings.ts
  - 로딩, 에러, 성공 상태 처리 필수

- 테스트 엔지니어: 통합 테스트 작성
  - 담당 파일: tests/api/settings.test.ts, tests/components/Settings.test.tsx
  - 정상 경로, 검증 에러, 엣지 케이스 커버 필수

중요 사항:
- 각 팀원은 서로 다른 파일을 담당한다. 파일 편집이 겹치면 안 된다.
- 백엔드와 프론트엔드는 구현 전에 서로 메시지를 보내서 API 계약
  (요청/응답 형태)을 합의해야 한다.
- 테스트 엔지니어는 API 계약 합의를 기다린 후, 그 계약 기반으로
  테스트를 작성해야 한다. 구현과 병렬로 진행 가능.

모든 팀원이 코딩을 시작하기 전에 계획 승인을 받아야 한다.
```

### 관찰 포인트

- [ ] 계획 승인 모드에서 각 팀원의 계획 검토
- [ ] API 계약에 대한 팀원 간 협의 과정 (직접 메시지)
- [ ] 파일 소유권이 잘 분리되었는지 확인
- [ ] 테스트 엔지니어가 구현과 병렬로 테스트를 작성하는 과정

### 팁

> 리더가 직접 코딩하지 않도록 **위임 모드** 활성화:

```
# 팀 생성 후 Shift+Tab을 눌러 위임 모드로 전환
# 또는 프롬프트에 명시:
너는 조율자 역할만 해. 코드를 직접 작성하지 마.
모든 팀원이 작업을 완료할 때까지 기다려.
```

---

## 시나리오 5: 리서치 팀 (중급)

### 목표

기술 선택이나 아키텍처 결정 전에 여러 관점에서 조사하고 토론한다.

### 프롬프트 (기술 선택)

```
React 앱에 쓸 상태 관리 솔루션을 선택해야 해.
에이전트 팀을 팀원 4명으로 만들어줘:

- Redux 전문가: Redux Toolkit을 조사해
  - 설정 복잡도, 보일러플레이트, DevTools, 미들웨어 생태계
  - 어떤 프로젝트 규모/유형에 가장 적합한지?

- Zustand 전문가: Zustand를 조사해
  - 단순성, 번들 사이즈, TypeScript 지원, 한계점
  - 어떤 프로젝트 규모/유형에 가장 적합한지?

- Jotai 전문가: Jotai를 조사해
  - 아토믹 모델, React Suspense 통합, 학습 곡선
  - 어떤 프로젝트 규모/유형에 가장 적합한지?

- 반대론자 (Devil's advocate): 세 가지 솔루션 모두에 도전해
  - 각각의 약점 찾기
  - 상태 관리 라이브러리가 정말 필요한지 의문 제기
  - React 내장 useState/useReducer/useContext 고려

규칙:
1. 각 전문가는 솔직한 장단점을 모두 제시해야 한다 (옹호만 하면 안 됨)
2. 반대론자는 각 전문가의 주장에 적극적으로 도전해야 한다
3. 전문가들은 도전에 대해 증거로 반응해야 한다
4. 최종 종합에는 가중치가 매겨진 의사결정 매트릭스를 포함해

우리 프로젝트 상황:
- 중간 규모 SPA (컴포넌트 약 50개)
- 프론트엔드 팀 3명
- 공유 상태가 중간 정도
- TypeScript 코드베이스
```

### 프롬프트 (아키텍처 결정)

```
새 백엔드를 마이크로서비스로 갈지 모듈러 모놀리스로 갈지 결정해야 해.
에이전트 팀을 만들어줘:

- 마이크로서비스 옹호자: 마이크로서비스의 장점을 주장해
- 모놀리스 옹호자: 모듈러 모놀리스의 장점을 주장해
- DevOps 검토자: 각 방식의 배포/운영 복잡도를 평가해
- 비용 분석가: 인프라 비용과 개발 비용을 비교해

우리 상황:
- 개발자 5명 팀
- 현재 분당 약 1,000 요청 처리
- 2년 내 10배 성장 예상
- AWS 사용 중

팀원들이 토론하고 마이그레이션 경로가 포함된 추천안을 만들어줘.
```

### 관찰 포인트

- [ ] 반대론자가 실제로 다른 팀원의 주장을 반박하는지
- [ ] 팀원 간 메시지로 토론이 발생하는지
- [ ] 최종 보고서에 모든 관점이 균형 있게 반영되는지

---

## 시나리오 6: 리팩토링 with 계획 승인 (고급)

### 목표

위험도가 높은 리팩토링에서 계획 승인 모드를 활용한다.

### 프롬프트

```
인증 모듈을 리팩토링해야 해. 모든 인증된 라우트에 영향을 주니까
위험도가 높아.

에이전트 팀을 팀원 3명으로 만들어줘. 모든 팀원은 변경 사항을
적용하기 전에 반드시 계획 승인을 받아야 해.

- 인증 아키텍트: 인증 플로우를 재설계해
  - 담당: src/auth/*.ts
  - 기존 세션과의 하위 호환성 유지 필수
  - 계획에 롤백 전략 포함 필수

- 마이그레이션 전문가: 데이터 마이그레이션 처리해
  - 담당: src/migrations/*.ts, src/scripts/*.ts
  - 무중단 마이그레이션 보장 필수
  - 계획에 검증 단계 포함 필수

- 테스트 수호자: 아무것도 깨지지 않도록 보장해
  - 담당: tests/auth/*.ts, tests/integration/*.ts
  - 프로덕션 코드 변경 전에 반드시 테스트를 먼저 작성해
  - 계획에 테스트 커버리지 목표 포함 필수

승인 기준:
- 롤백 전략이 포함된 계획만 승인해
- 테스트 커버리지 80% 이상을 포함하는 계획만 승인해
- 팀원의 소유권 밖의 파일을 수정하는 계획은 거부해

모든 계획이 승인되고 구현이 끝나면, 전체 테스트 스위트를
실행해서 아무것도 깨지지 않았는지 확인해.
```

### 관찰 포인트

- [ ] 각 팀원이 계획을 제출하는 과정
- [ ] 리더가 승인 기준에 따라 계획을 검토/거부하는 과정
- [ ] 거부된 계획이 수정 후 재제출되는 과정
- [ ] 승인 후 구현이 시작되는 과정
- [ ] 파일 소유권 경계가 지켜지는지

### 팁

> 리더에게 승인 기준을 명확히 할수록 자율적으로 판단한다:

```
다음 조건에 해당하는 계획은 거부해:
- 롤백 단계가 포함되지 않은 계획
- 팀원의 소유권 밖 파일을 수정하는 계획
- 하위 호환성을 다루지 않는 계획
```

---

## 시나리오 7: 대규모 마이그레이션 (고급)

### 목표

대규모 코드베이스 마이그레이션을 파일 소유권을 분리하여 병렬로 수행한다.

### 프롬프트

```
코드베이스를 CommonJS (require/module.exports)에서
ES Modules (import/export)로 마이그레이션해야 해.
에이전트 팀을 팀원 5명으로 만들어줘.

디렉토리별로 분담해:
- 팀원 1: src/api/ 전체 파일 마이그레이션
- 팀원 2: src/models/ 전체 파일 마이그레이션
- 팀원 3: src/utils/와 src/helpers/ 전체 파일 마이그레이션
- 팀원 4: src/services/ 전체 파일 마이그레이션
- 팀원 5: 설정 파일 업데이트 (package.json, tsconfig.json,
  jest.config.js)와 교차 모듈 import 이슈 수정

작업 종속성:
- 팀원 1~4는 병렬로 작업 가능 (파일 겹침 없음)
- 팀원 5는 다른 모든 팀원이 완료될 때까지 대기해야 함
  (설정 변경은 모든 import 경로를 알아야 하므로)

각 팀원은:
1. 수정할 모든 파일 목록을 먼저 나열해
2. 마이그레이션 변경 수행
3. 자기 파일에 대해 린트와 타입 체크 실행
4. 교차 모듈 의존성 이슈가 있으면 팀에 보고해

모두 끝나면 전체 테스트 스위트를 실행해.
```

### 관찰 포인트

- [ ] 작업 종속성이 올바르게 설정되는지 (팀원 5가 차단됨)
- [ ] 종속성 완료 시 자동 차단 해제 확인
- [ ] 교차 모듈 의존성 문제 시 팀원 간 통신 관찰
- [ ] 5번 팀원이 모든 변경을 통합하는 과정

---

## 시나리오 8: 위임 모드 마스터하기 (고급)

### 목표

리더가 코드를 직접 작성하지 않고 순수하게 조율만 하는 방식을 체험한다.

### 프롬프트

```
위임 모드를 연습하고 싶어. 에이전트 팀을 팀원 3명으로 만들어서
간단한 할 일 목록(TODO) REST API 앱을 구현해줘.

- 백엔드 개발자: Express로 CRUD 엔드포인트 구현
- 프론트엔드 개발자: 간단한 HTML/CSS/JS 프론트엔드 구현
- 테스터: jest/supertest로 API 테스트 작성

나는 위임 모드로만 운영할 거야. 코드를 직접 작성하지 않을 거야.
나는 다음만 할 거야:
1. 작업 생성 및 할당
2. 진행 상황 검토
3. 팀원이 잘못된 방향으로 가면 재지정
4. 최종 결과 종합

먼저 작업 목록을 만들고 팀원들에게 할당해줘.
내가 위임 모드로 전환할 때까지 기다려.
```

### 실행 순서

1. 프롬프트 입력
2. 팀이 생성되면 `Shift+Tab`으로 **위임 모드 전환**
3. 리더의 행동을 관찰:
   - 작업 분해
   - 팀원에게 작업 할당
   - 팀원 진행 상황 모니터링
   - 필요 시 재지정

### 개입 연습

팀이 작업 중일 때 다음을 시도해본다:

```
# 팀원에게 직접 메시지 (Shift+Up/Down으로 선택 후)
모든 엔드포인트에 /api/v1/ 프리픽스를 붙여줘

# 작업 재할당
데이터베이스 설정 작업을 백엔드 개발자에서 테스터로 옮겨줘

# 새 요구사항 추가
GET /todos 엔드포인트에 페이지네이션 지원을 추가해줘.
이걸 새 작업으로 만들어서 백엔드 개발자에게 할당해.
```

### 관찰 포인트

- [ ] 위임 모드에서 리더가 코드를 직접 작성하려는 시도를 하는지
- [ ] 작업 재할당이 원활하게 되는지
- [ ] 새 요구사항 추가 시 팀원이 즉시 반응하는지

---

## 시나리오 9: 팀원 간 토론 유도 (고급)

### 목표

팀원들이 서로 직접 대화하며 합의에 도달하는 과정을 관찰한다.

### 프롬프트

```
이커머스 플랫폼의 데이터베이스 스키마를 설계할 에이전트 팀을
팀원 3명으로 만들어줘.

- 데이터 모델러: 핵심 스키마 설계 (사용자, 상품, 주문)
- 성능 엔지니어: 스키마의 쿼리 성능을 검토하고,
  필요한 곳에 인덱스와 비정규화를 제안해
- 보안 감사자: 스키마의 데이터 보호, PII 처리,
  접근 제어를 검토해

핵심 지시사항:
- 데이터 모델러가 초기 스키마를 제안한 후, 성능 엔지니어와
  보안 감사자는 리더에게 보고하지 말고 데이터 모델러에게
  직접 메시지를 보내서 우려 사항을 전달해야 한다.
- 데이터 모델러는 각 우려 사항에 응답하고 스키마를 조정해야 한다.
- 이 주고받기는 세 명 모두 합의에 도달할 때까지 계속되어야 한다.
- 합의 후에만 나에게 최종 스키마를 보고해.

팀 토론을 통한 최소 2라운드의 수정 과정이 있어야 해.
```

### 관찰 포인트

- [ ] 팀원 간 직접 메시지가 실제로 발생하는지
- [ ] 토론을 통해 스키마가 개선되는 과정
- [ ] 합의 도달 과정 (어떤 타협이 이루어지는지)
- [ ] Peer DM 요약이 리더의 유휴 알림에 포함되는지

---

## 시나리오 10: 문제 해결 & 트러블슈팅 연습

### 목표

에이전트 팀에서 발생할 수 있는 문제 상황을 의도적으로 만들고 해결한다.

### 10-1. 팀원이 멈춘 경우

```
에이전트 팀을 팀원 2명으로 만들어줘.
팀원 1에게 불가능한 작업을 줘
(예: "존재하지 않는 파일 src/nonexistent/magic.ts를 찾아").
어떤 일이 일어나는지 관찰하고 복구를 연습해:
1. 팀원의 상태 확인
2. 수정된 지시사항으로 직접 메시지 전송
3. 또는 대체 팀원 생성
```

### 10-2. 리더가 먼저 끝나려는 경우

```
코드 검토 작업을 위해 에이전트 팀을 팀원 2명으로 만들어줘.
리더가 너무 일찍 마무리하려고 하면 이렇게 말해봐:
"팀원들이 작업을 완료할 때까지 기다려"
```

### 10-3. 파일 충돌 시뮬레이션

```
에이전트 팀을 팀원 2명으로 만들어줘. 의도적으로 두 팀원 모두에게
같은 파일(src/index.ts)을 편집하도록 할당해.
충돌을 관찰하고 해결을 연습해:
1. 충돌 식별
2. 파일 소유권 재할당
3. 한 팀원이 변경 사항을 다시 적용
```

### 10-4. 작업 종속성 교착 상태

```
에이전트 팀을 팀원 2명으로 만들어줘.
- 작업 A (팀원 1): 작업 B에 의존
- 작업 B (팀원 2): 작업 A에 의존
교착 상태를 관찰하고 해결을 연습해:
1. 순환 종속성 식별
2. 종속성 하나를 제거해서 순환 끊기
3. 필요하면 작업 상태를 수동으로 업데이트
```

---

## 팀 정리 체크리스트

모든 시나리오 완료 후 반드시 정리:

```
# 1. 팀원 종료
모든 팀원에게 종료를 요청해줘

# 2. 팀 리소스 정리
팀을 정리해줘

# 3. (분할 창 모드 사용 시) 고아 tmux 세션 확인
tmux ls
tmux kill-session -t <session-name>
```

---

## 실습 진행 순서 권장

```
입문 ──────────────────────────────────────────── 고급

시나리오 1     시나리오 2     시나리오 3     시나리오 6
첫 번째 팀  →  병렬 검토  →  가설 디버깅  →  계획 승인
                  │                           │
                  ▼                           ▼
             시나리오 5     시나리오 4     시나리오 7
             리서치 팀   →  기능 개발  →  대규모 마이그레이션
                                            │
                                            ▼
                          시나리오 8     시나리오 9
                          위임 모드  →  팀원 간 토론
                                            │
                                            ▼
                                       시나리오 10
                                       트러블슈팅
```

---

## 비용 최적화 팁

| 팁 | 설명 |
|---|---|
| **팀원 수 최소화** | 꼭 필요한 만큼만. 3명이면 충분한 작업에 5명을 넣지 마라 |
| **Sonnet 사용** | 팀원에게 `각 팀원은 Sonnet 모델을 사용해` 지정. 리서치 작업에 Opus는 과하다 |
| **broadcast 자제** | DM(`message`)을 기본으로. broadcast는 긴급 상황에만 |
| **범위 한정** | "전체 코드베이스 검토" 대신 "src/auth/ 디렉토리만 검토" |
| **팀원당 작업 5~6개** | 너무 적으면 유휴, 너무 많으면 관리 어려움 |
| **일찍 정리** | 작업 완료된 팀원은 바로 종료. 유휴 상태로 방치하지 마라 |
